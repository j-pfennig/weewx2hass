#!/usr/bin/bash
CEN_LEGAL="Copyright Dr. J. Pfennig (c) 2024-2025; BSD License"
CEN_TITLE="Monitor for weewx2hass data, simple ASCII-art/HTML clock"

# NOTE this script contains annotations to make 'shellcheck' happy. To run
# 'shellcheck' use: centauricreate --check <file>   # see centauri-bash-lib

CEN_FEATURE_F=1                 # enable option force
CEN_VERSION='0.10'

# declare global variables ...

CEN_OPT_ASCII=                  # see --ascii
CEN_OPT_BASE=                   # see --base
CEN_OPT_CLOCK=                  # see --clock
CEN_OPT_FILE=                   # see --file
CEN_OPT_HOST='localhost'        # see --host
CEN_OPT_INDENT=                 # see --indent
CEN_OPT_TERM=                   # see --terminal
CEN_OPT_URL=                    # see --url
CEN_OPT_VIEWER=                 # see --viewer
CEN_OPT_WAIT=                   # see --wait

DAT_MYSELF=                     # own path
DAT_BASEDIR="~/.local/centauriclock"
DAT_BASENAME=                   # set in config_fldr()

                                # List of tag options for subscribe
DAT_MQTOPICS=('-t' 'weewx/inside' '-t' 'weewx/outside')

DAT_SERIALIZER=                 # PID of serializer sub shell
DAT_SUBSCRIBER=                 # PID of subscriber child process
DAT_DISPLAY=                    # PID of qml display

DAT_MQTTPIPE=                   # pipe for MQtt Payload data
DAT_MQTTDATA=                   # serialized subscription data
DAT_UPDATED=                    # update timestamp
DAT_COUNTER=0                   # simple update counter
DAT_POLLMOD=10                  # modulo for file polling
DAT_FONT=                       # toilet font
DAT_QMLVERSION=                 # qml or qml-qt6
declare -A DAT_DICTDATA         # to serialize/deserialize

# ------------------------------------------------------------------------------
# Manage configuration folder
# ------------------------------------------------------------------------------
config_fldr() {
    if [ "${CEN_OPT_BASE:--}" = '-' ] ; then
        eval CEN_OPT_BASE="$DAT_BASEDIR"
        folder -f -m -c -- "$CEN_OPT_BASE"
    else
       [ -z "$CEN_OPT_BASE" ] && eval CEN_OPT_BASE="$DAT_BASEDIR"
    fi

    if folder -q -c -- "$CEN_OPT_BASE" ; then
        DAT_BASENAME="$CEN_OPT_BASE/centauriclock"
        if [ -z "$DAT_QMLVERSION" ] ; then
            remove -- "$DAT_BASENAME.qml"
        else
            [ -e "$DAT_BASENAME.qml" ] || remove -- "$DAT_BASENAME.html"
            create_qml  "$DAT_BASENAME.qml"
        fi
        create_html "$DAT_BASENAME.html"
        create_bash "$DAT_BASENAME.bash"
    else
        fatal "Missing configuration:" "$CEN_OPT_BASE"
    fi
}

# ------------------------------------------------------------------------------
# Create clock bash helper: <path>
# ------------------------------------------------------------------------------
create_bash() {
    if [ -e "$1" ] ; then
        [ -z "$CEN_OPT_FORCE" ] && return
        [ -w "$1" ] || return
    fi
    create -t -c -- "$1" <<!EOF
#!/usr/bin/bash

# The datafile and the HTML file must be in the same folder and must not be
# symlinks. Otherwise the browser will not load the datafile ...
datafile='${1%.*}.js'

# The --wait option is required for appliances to wait for the network to
# become ready ...
dataopts="--file \$datafile --quiet --host=raspi1 --wait=-"
datatool='${DAT_MYSELF:-$CEN_NAME}'

# Run weewx data import
if [ -w "\$datafile" -a -x "\$datatool" ] ; then
    echo "temperature_outside=''; temperature_inside=''" >"\$datafile"
    exec "\$datatool" \$dataopts &
fi

# end
!EOF
    system -e -- chmod 775 "$1"
}

# ------------------------------------------------------------------------------
# Create clock html: <path>
# ------------------------------------------------------------------------------
create_html() {
    if [ -e "$1" ] ; then
        [ -z "$CEN_OPT_FORCE" ] && return
        [ -w "$1" ] || return
    fi
    create -t -c -- "$1" <<!EOF
<!DOCTYPE html>
<html lang="en" class='croot'>
<head>
  <meta charset="UTF-8">
  <title>JavaScript Digital Clock</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      height: 100vh;
    }

    .croot {
      /* Noto Sans: is a tabular font and can be downloaded from Google, it is
            not installed by default.
         Quicksand: very nice font, but not tabular. This is why we use two
            cells to display hour and minute.
         sans-serif: used as a fall-back (typically aliased to 'DejaVu Sans'.

         font-size: use '10vw' for nice automatic scaling on 16:9 displays
      */
      font-family: "Noto Sans", "Quicksand", "sans-serif";
      font-size: 10vw;
      font-variant-numeric: tabular-nums;
      overflow: hidden;
    }

    .cclock {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background-color: black;
    }

    .ctime {
      font-size: 3.9rem;
      font-weight: bold;
      color: #ccf;
      margin-top: calc(10vh - 2.5rem);
      /* margin-top: -15vh;   set via dom when no temperatures are shown */
      margin-bottom: calc(15vh - 1.5rem);
    }

    .cdigit {
      display: inline-block;
      width: 46vw;
    }

    .cdsepa {
      display: inline-block;
      font-size: 2.5rem;
      line-height: 0.6rem;
      width: 6vw;
    }

    .csecs {
        color: #00ffff;
        width: 95%;
      margin-bottom: calc(20vh - 1.2rem);
    }

    .csecs-bar {
        height: 0.12rem;
        background-color: beige;
        /* it seems that only 'px' is working here */
        border-radius: 0.1rem;
    }

    .cidate {
      color: #aff;
      font-size: 0.6rem;
      text-align: center;
      margin-top: calc(20vh - 0.8rem);
    }
    .citemp {
      color: #aff;
      margin-bottom: -10vh;
    }

    .ctemp {
      position: absolute;
      /* justify-content: center; */
      font-size: 1.8rem;
      text-align: right;
    }

    .cdate {
      display: inline-block;
      font-size: 0.65rem;
      line-height: 0.7rem;
      margin-top: 9vh;
      margin-top: calc(8vh - 0.1rem);
      text-align: center;
    }
    .cdegr {
      position: absolute;
      justify-content: top;
      margin-top: 2vh;
      font-size: 0.9rem;
    }

  </style>
</head>

<body>
  <div class="cclock">
    <div class="ctime">
        <span id="ahour" class="cdigit" style="text-align: right;">--</span><span id="asepa" class="cdsepa">:</br>&nbsp;</span><span id="aminu" class="cdigit">--</span>
    </div>
    <div class="csecs"><div id="asecs" class="csecs-bar"></div></div>
    <div class="cidate" hidden></div>
    <div class="citemp">
        <span class="ctemp" style="right: 80vw"><span id="atmp1"></span><span class="cdegr" id="adeg1">°</span></span>
        <span class="cdate" id="adate"></span>
        <span class="ctemp" style="right: 4vw"><span id="atmp2"></span><span class="cdegr" id=adeg2>°</span></span>
    </div>
  </div>

<script>
var centauriclock_data='';     // CORS http url to load data, use file if empty
var temperature_inside='--';
var temperature_outside='--';
</script>
<script src='centauriclock.js'></script>
<script>

// query parameter: language and font scaling
var lang='de'
var ourl = window.location.search.substring(1);
var aurl = ourl.split('&');
for (var indx = 0; indx < aurl.length; indx++)
{ var kval = aurl[indx].split('=');
  switch(kval[0]) {
    case 'lang':
      lang = kval[1].substring(0,2)
    case 'rsiz':
      document.querySelector('.croot').style.fontSize = kval[1];
  }
}
delete ourl; delete aurl; delete kval; delete indx

// more global variables
var htmld = document.firstElementChild;
htmld.setAttribute('onkeydown', 'keydown(event)');
htmld.setAttribute('ontouchstart', 'touch(event)');

var vhour = document.getElementById("ahour");
var vminu = document.getElementById("aminu");
var vdate = document.getElementById("adate");
var vtmp1 = document.getElementById("atmp1");
var vtmp2 = document.getElementById("atmp2");
var vdeg1 = document.getElementById("adeg1");
var vdeg2 = document.getElementById("adeg2");

// store day and month name in an array
switch (lang) {
  case 'de':
    var dayNames = 'Montag Dienstag Mittwoch Donnerstag Freitag Sonnabend Sonntag';
    var monthNames = 'Januar Februar März April Mai Juni' +
                     'Juli August September Oktober November Dezember' +
                     '- - - - - - - - Sept. Okt. Nov. Dez.'; break;
  case 'fr':
    var dayNames = 'Lundi Mardi Mercredi Jeudi Vendredi Samedi Dimanche';
    var monthNames = 'Janvier Février Mars Avril Mai Juin' +
                     'Juillet Août Septembre Octobre Novembre Décembre'; break;
  default:
    var dayNames = 'Monday Tuesday Wednesday Thursday Friday Saturday Sunday';
    var monthNames = 'January February March April May June ' +
                     'July August September October November December ' +
                     'Jan Feb Mar Apr - Jun Jul Aug Sep Oct Nov Dec';
}
dayNames = dayNames.split(' ')
monthNames = monthNames.split(' ')

// get progress bar element
var sbar = document.getElementById("asecs");
var last_minutes

function updateClock() {
  // Get the current time, day , month and year
  var now = new Date();
  var minutes = now.getMinutes();
  var seconds = now.getSeconds();

  sbar.style.width = (seconds * 100 / 59) + '%';
  if ( minutes == last_minutes ) return
  last_minutes = minutes

  var hours = now.getHours();
  var day = now.getDay();               // BEWARE: 0:=sunday WHY THE HELL!
  var date = now.getDate();
  var month = now.getMonth();
  var year = now.getFullYear();

  // fix the idiotic day-of-week according to ISO standard
  day = day > 0 ? day - 1 : 6

  // format date and time
  minutes = minutes < 10 ? '0' + minutes : minutes;
  seconds = seconds < 10 ? '0' + seconds : seconds;

  // display date and time
  var line1 = dayNames[day] ; var line2 = monthNames[month]
  if (temperature_outside != '--' && monthNames[month+12] != '-') {
    line2 = monthNames[month+12] ?? line2
  }
  switch (lang) {
    case 'de': line2 = date + '. '+ line2 + ' ' + year; break;
    case 'en': line2 = date + ' ' + line2 + ' ' + year; break;
    case 'fr': line1 = line1 + ' ' + date; line2 = line2 + ' ' + year; break;
    case 'us': hours = hours % 12 || 12;
               line2 = date + ' ' + line2 + ' ' + year; break;
    default:  line1 = dayNames[day];
              month = (month < 9) ? '0' + (month+1) : month + 1;
              data = (date < 10) ? '0' + date : date;
              line2 = year + '-' + month + '-' + date;
  }

  vhour.innerHTML = hours; vminu.innerHTML = minutes;
  if (temperature_outside == '--') {
    document.querySelector('.cidate').innerHTML = line1 + ' ' + line2;
  } else {
    vdate.innerHTML = line1 + '</br>' + line2;
  }

  // load temperatures from via http
  if (centauriclock_data != '') {
    fetch(centauriclock_data)
      .then(x => x.text())
      .then(y => updateTemp(y));
  }
}

function updateTempDisp(eltt, eltd, temp) {
   var color
   if (temp == '' || temp == '-') {
     temp='--';
   }
   else if (temp.substring(0,1) == '-') {
     temp = -Math.round(temp);
     color = '#66f';
   }
   else {
     temp = Math.round(temp);
     color = '#f88';
  }
  eltt.innerHTML = temp;
  eltt.style.color=color; eltd.style.color=color;
}

function updateTemp(text) {
  eval(text)
  updateTempDisp(vtmp1, vdeg1, temperature_outside)
  updateTempDisp(vtmp2, vdeg2, temperature_inside)
}

// keys q/Escape and touch are handled in qml code via console logging
function keydown(event) {
  switch(event.key) {
    case 'd': vhour.innerHTML=44; vminu.innerHTML=44;
    updateTempDisp(vtmp1, vdeg1, -44);
    updateTempDisp(vtmp2, vdeg2, 44);
    break;
    case 'f': console.log("FULL"); break;
    case 'w': console.log("WIND"); break;
    case 'q':
    case 'Escape': console.log("QUIT"); break;
  }
}
function touch(event) {
  console.log("EXIT") ;
}

// load temperatures from via file using refresh
if (centauriclock_data == '') {
  // disable temperature display (no data file)
  if (temperature_outside == '--') {
    document.querySelector('.citemp').style.display='none'
    document.querySelector('.cidate').style.display='block'
    document.querySelector('.ctime').style.marginTop='-25vh';
    document.querySelector('.ctime').style.marginBottom='-8vh';
  } else {
    setTimeout(function() { location.reload(); }, 300000);
    updateTempDisp(vtmp1, vdeg1, temperature_outside);
    updateTempDisp(vtmp2, vdeg2, temperature_inside);
  }
}

// main script part ...
updateClock();
setInterval(updateClock, 1000);

</script></body>
!EOF
}

# ------------------------------------------------------------------------------
# Create clock qml: <path>
# ------------------------------------------------------------------------------
create_qml() {
    local nown
    if [ -e "$1" ] ; then
        nown=1                              # no chown for existing file
        [ -w "$1" ] || return
    fi
    local visi="Windowed" ; [ -n "$CEN_OPT_TERM" ] && visi="FullScreen"
    create -t -c -- "$1" <<!EOF
#!$DAT_QMLVERSION

/* -----------------------------------------------------------------------------
   This is a qml based web view for clock.html that should work with debian
   bookworm, txixie and Rapsberry PI OS. To pull in dependencies just run:

        apt install falkon qml      # bookworm
        apt install falkon qml-qt6  # trixie

   Rasberry Pi5: qt5  only works for 4k pages. The raspberry 2712 kernel thus
   cannot be used and must be removed. The Pi5 works fine (but is a little bit
   slower) using the v8 kernel. Qt6 support for large pages works fine.
   ---------------------------------------------------------------------------- */

import QtQuick 2.2
import QtQuick.Window 2.2
import QtWebEngine 1.2
Window {
    id: window
    title: "$CEN_NAME"
    visible: true
    visibility: "$visi"

    function cen_posx() {
        return (Screen.desktopAvailableWidth - (Screen.desktopAvailableWidth * 6) / 10) / 2; }
    function cen_posy() {
        return (Screen.desktopAvailableHeight - (Screen.desktopAvailableHeight * 4) / 5) / 2; }
    x: cen_posx() ; y: cen_posy()

    function cen_wide() { return (Screen.desktopAvailableWidth * 6) / 10 ; }
    function cen_heig() { return (Screen.desktopAvailableHeight * 4) / 5 ; }
    width: cen_wide() ; height: cen_heig()

    WebEngineView {
        anchors.fill: parent
        url: "file:$DAT_BASENAME.html"
        focus: true
        zoomFactor: Screen.pixelDensity / 4.5
        onJavaScriptConsoleMessage: {
            if (message == 'FULL') window.visibility = "FullScreen";
            if (message == 'WIND') window.visibility = "Windowed";
            if (message == 'EXIT') Qt.exit(1);
            if (message == 'QUIT') Qt.quit();
            console.log("Received termination message from viewer: " + message);
        }
        settings.localContentCanAccessFileUrls: true
        settings.localContentCanAccessRemoteUrls: true
   }
}
!EOF
    [ -z "$nown" ] && system -e -- chmod 775 "$1"
}

# ------------------------------------------------------------------------------
# Background processes/sub-shells
# ------------------------------------------------------------------------------

# QML display
display() {
    # create $CEN_TEMPFILE.qml
    # copy clock.html $CEN_TEMPFILE.html
    system -e /admin/Display/clock/clock-launcher.qml
    message "QML display closed, terminating workers"
    {   kill -n 1 "$DAT_SUBSCRIBER"
        kill -n 1 "$DAT_SERIALIZER"
        kill -n 1 "$$"
    } 2>/dev/null
}

# MQtt subscription starts in a sub-shell; exec replaces useless bash
subscriber() {
    printf '%s --\n' "${DAT_MQTOPICS[@]}"
    set -f ; set -- $CEN_OPT_HOST               # glob stays off
    [ "$CEN_OPT_WAIT" = '-' ] && CEN_OPT_WAIT=1883
    local addr="$1:$CEN_OPT_WAIT" wcnt=0
    while [ -n "$CEN_OPT_WAIT" ] ; do
        echo 2>/dev/null >"/dev/tcp/${addr/:/\/}" && break
        [ "$wcnt" = 0 ] && message -a $"Waiting for mqtt connection:" "$addr"
        sleep 3 ; ((wcnt += 1))
    done
    [ "$wcnt" = 0 ] || message -a $"Connection to mqtt is ready"

    # CEN_OPT_HOST is not quoted to allow extra parameters ...
    exec mosquitto_sub -h $CEN_OPT_HOST -F "%t %p" "${DAT_MQTOPICS[@]}"
}

# helper for parsing: <expr> <data> [<mext>]|- [<merr>]|- <vnam>...
___regexp() {
    if [[ "$2" =~ $1 ]] ; then
        [ "$2" != "$BASH_REMATCH" ] && [ "${3:--}" != '-' ] &&
            trace -a -c 'json parser' -- "$3" "'${2/$BASH_REMATCH/ ... }'"
        [ $# -le 4 ] && return 0
        shift 4 ; local indx=1
        while [ $# != 0 ] ; do
            [ "${1:--}" = '-' ] || printf -v "$1" '%s' "${BASH_REMATCH[indx]}"
            shift ; ((indx += 1))
        done
        return 0
    fi
    [ "${3:--}" != '-' ] && trace -a -c 'json parser' -- "$4"
    return 1
}

# simple JSON parser that understands only key/value entries
___parser() {
    # <obj>
    local jlst='[[:space:]]*\{[[:space:]]*(.*)*\}[[:space:]]*'
    # <key> <separator> <remainder>
    local jelt='[[:space:],]*\"([^\"]+)\"[[:space:]]*([:,])?[[:space:]]*(.*)'
    # <value> <quoted> <plain> <remainder>
    local jval='(\"([^\"]*)\"|([^[:space:]\"]*))[[:space:]]*(.*)'

    local dstr dkey ddel dall dquo dpln
    # step 1: isolate the object content
    ___regexp "$jlst" "$2" "Extra chars" "No JSON object" dstr || return
    trace -c 'json parser doc' -a -- "$1" "${dstr//[[:space:]]/ }"
    while : ; do
        [ -z "${dstr//[[:space:]]/}" ] && return
        # trace -a -c 'json parser' "'$dstr'"
        # step 2: get <key> [<deli>] [<rest>]
        ___regexp "$jelt" "$dstr" "Extra chars" "No key" dkey ddel dstr || return
        if [ "$ddel" = ':' ] ; then
            # step 3: get value (can be missing, quoted or a plain word)
            ___regexp "$jval" "$dstr" "Extra chars" "Error" dall dquo dpln dstr || return
            if [ "${dall:-,}" = ',' ] ; then dval='-'
            elif [ -n "$dquo" ] ; then       dval="$dquo"
            else                             dval="$dpln"
            fi
            trace -a -p -c 'json parser' "key %-15s  value %s" "'$dkey'" "'$dval'"
            DAT_DICTDATA["$1/$dkey"]="$dval"
        else
            trace -a -c 'json parser' "expected colon:" "$dkey"
        fi
    done
}

# saving payload data to a file runs in a sub-shell (not calling quit)
serializer() {
    local mesg mtag last
    # shellcheck disable=SC2162     # escaping \ is intended
    while read mesg ; do
        # get topic and a JSON document
        #trace -a -c 'serializer read' -- "$mesg"
        # shellcheck disable=SC1083
        case "${mesg// /}" in
            */*{*}) mtag="${mesg%% *}" ; json="${mesg#*\{}{" ;;
            */*{*)  mtag="${mesg%% *}" ; json="${mesg#*\{}{" ; continue ;;
            *})     json+=" $mesg" ;;
            *)      [ -n "$mtag" ] && json+=" $mesg" ; continue ;;
        esac
        [ -z "$mtag" -o -z "$json" ] && continue

        # parse JSON into dictionary and serialize it to file
        ___parser "$mtag" "$json"
                                                            # shellcheck disable=SC2124
        mesg="${DAT_DICTDATA[@]@A}" ; mesg="${mesg#* -A }"
        if [ "$last" = "$mesg" ] ; then
            trace -a -c 'serializer info' "Data not changed"
        else
            last="$mesg"
            trace -a -c 'serializer write' "${#DAT_DICTDATA[@]} items"
            echo "$mesg" >"$DAT_MQTTDATA"
        fi
        mtag=                                               # wait for next topic/doc
    done <"$DAT_MQTTPIPE"
    exit 1                                                  # must not call quit
}

# this version has a cripled parser but may help understanding the logic
#serializer() {
#    local mesg mtag last
#    while read mesg ; do
#        trace -c 'serializer' -a -- "$mesg"
#        case "$mesg" in
#            */*{)   mtag="${mesg%% *}" ;;
#            *})     mtag=
#                    mesg="${DAT_DICTDATA[@]@A}" ; mesg="${mesg#* -A }"
#                    if [ "$last" = "$mesg" ] ; then
#                        trace -a -c 'serializer' "Data not changed"
#                    else
#                        last="$mesg"
#                        trace -a -c 'serializer' "${mesg#*=}"
#                        echo "$mesg" >"$DAT_MQTTDATA"
#                    fi
#                    ;;
#            *)      [ -z "$mtag" ] && continue
#                    mesg="${mesg%\",}" ; mesg="${mesg/\": / }" ; mesg="${mesg//\"/}"
#                    DAT_DICTDATA["$mtag/${mesg%% *}"]="${mesg#* }"
#        esac
#    done <"$DAT_MQTTPIPE"
#    exit 1                                  # must not call quit
#}

# ------------------------------------------------------------------------------
# Display updates
# ------------------------------------------------------------------------------

DAT_UPDATE_HHMM=            # time in HHMM format
DAT_UPDATE_YYMD=            # ISO date and localized weekday
DAT_OUTPUT_HHMM=            # toilet output (arrays) ...
DAT_OUTPUT_YYMD=
DAT_OUTPUT_TEMP=
DAT_OUTPUT_CLEAR=           # clear screen escape sequence

# used by main bash instance to load data written by serializer()
# shellcheck disable=SC2317
update_data() {
    if ((DAT_COUNTER % DAT_POLLMOD)) ; then                 # run only every DAT_POLLMOD sec.
        # trace -a "Skip:" "No data check"
        return 1
    elif ! [ "$DAT_MQTTDATA" -nt "$DAT_UPDATED" ] ; then    # run only on data update
        return 1
    fi
                                                            # shellcheck disable=SC1090
    source "$DAT_MQTTDATA"
    [ "${#DAT_DICTDATA[@]}" = 0 ] && return 1
    trace -a -c 'update_data' "${#DAT_DICTDATA[@]} items"
    true >"$DAT_UPDATED"                                    # update timestamp
    return 0
}

# Clock mockup, run toilet after updates, dump to console
                                                            # shellcheck disable=SC2317
update_clock() {
    local tnow="$EPOCHSECONDS" hhmm yymd fupd line
    # printf -v scnd '%(%S)T' "$tnow"                       # unused in this demo
    printf -v hhmm '%(%H%M)T' "$tnow"
    printf -v yymd '%(%Y-%m-%d %A)T' "$tnow"

    [ "$CEN_OPT_ASCII" = 0 ] && DAT_FONT='ascii' || DAT_FONT='mono'

    if [ "$hhmm" != "$DAT_UPDATE_HHMM" ] ; then
        DAT_UPDATE_HHMM="$hhmm" ; fupd=1
        system -f -a DAT_OUTPUT_HHMM -- toilet -f "big${DAT_FONT}12" -t -- \
                     "${DAT_UPDATE_HHMM::2}:${DAT_UPDATE_HHMM:2}"
    fi
    if [ "$yymd" != "$DAT_UPDATE_YYMD" ] ; then
        DAT_UPDATE_YYMD="$yymd" ; fupd=1
        system -f -a DAT_OUTPUT_YYMD -- toilet -f "sm${DAT_FONT}9" -t -- \
                     "${DAT_UPDATE_YYMD#* } ${DAT_UPDATE_YYMD% *}"
    fi
    if update_data || [ -z "$DAT_OUTPUT_TEMP" ] ; then
        local tmp1="${DAT_DICTDATA["${DAT_MQTOPICS[1]}/temperature"]}"
        local tmp2="${DAT_DICTDATA["${DAT_MQTOPICS[3]}/temperature"]}"
        printf -v line '%5s°  %5s°' "${tmp1:---.-}" "${tmp2:---.-}"
        system -f -a DAT_OUTPUT_TEMP -- toilet -f "sm${DAT_FONT}12" -t -- "$line"

    fi
    [ -z "$fupd" ] && return

    local icol="${CEN_OPT_INDENT%[!0-9]*}" irow="${CEN_OPT_INDENT#*[!0-9]}"
    printf -v icol "%${icol:-0}s"
    echo -n "$DAT_OUTPUT_CLEAR"
    while [ "${irow:-0}" -gt 0 ] ; do
        echo ; ((irow -= 1))
    done
    for line in "${DAT_OUTPUT_HHMM[@]:3:13}" ; do echo "$icol            $line" ; done
    for line in "${DAT_OUTPUT_YYMD[@]}"      ; do echo "$icol$line" ; done
    for line in "${DAT_OUTPUT_TEMP[@]:1:6}"  ; do echo "$icol   $line" ; done
                                               echo -n "$icol   ${DAT_OUTPUT_TEMP[7]}  "
}

# Monitor mode, simple text messages
                                                            # shellcheck disable=SC2317
update_text() {
    local tnow="$EPOCHSECONDS" hhmm
    printf -v hhmm '%(%H%M)T' "$tnow"
    if [ "$hhmm" != "$DAT_UPDATE_HHMM" ] ; then
        DAT_UPDATE_HHMM="$hhmm"
        message $"Time:" "${hhmm::2}:${hhmm:2}"
    fi
    update_data || return
    local dat1="${DAT_DICTDATA["${DAT_MQTOPICS[1]}/temperature"]}"
    local dat2="${DAT_DICTDATA["${DAT_MQTOPICS[3]}/temperature"]}"
    message -p $"MQtt: Temperatures   %6s°  %6s°" "${dat1:---.-}" "${dat2:---.-}"
    dat1="${DAT_DICTDATA["${DAT_MQTOPICS[1]}/humidity"]}"
    dat2="${DAT_DICTDATA["${DAT_MQTOPICS[3]}/humidity"]}"
    [ -n "$dat1$dat2" ] &&
        message -a -p $"      Humidity %12s%%  %6s%%" "${dat1:---.-}" "${dat2:---.-}"
}

# File output mode

update_file() {
    update_data || return
    {   local dat1="${DAT_DICTDATA["${DAT_MQTOPICS[1]}/temperature"]}"
        local dat2="${DAT_DICTDATA["${DAT_MQTOPICS[3]}/temperature"]}"
        printf 'temperature_inside="%s"; temperature_outside="%s";\n' "$dat1" "$dat2"
        dat1="${DAT_DICTDATA["${DAT_MQTOPICS[1]}/humidity"]}"
        dat2="${DAT_DICTDATA["${DAT_MQTOPICS[3]}/humidity"]}"
        [ -n "$dat1$dat2" ] &&
            printf 'humidity_inside="%s"; humidity_outside="%s;"\n' "$dat1" "$dat2"
    } >"$CEN_OPT_FILE"
}

run_clock() {
    local temp
    if [ -z "$CEN_OPT_FORCE" ] && [ -z "$DISPLAY" -o "${XDG_SESSION_TYPE:-tty}" = 'tty' ] ; then
        quit "No GUI session detected, try option '--force' to override"
    elif system -c -- /usr/bin/qml-qt6 ; then
        DAT_QMLVERSION="/usr/bin/qml-qt6"
    elif system -c -- /usr/bin/qml ; then
        DAT_QMLVERSION="/usr/bin/qml"
    elif ! system -c -- x-www-browser ; then
         quit "Neither qml, qml-qt6 or x-www-browser found, cannot run in GUI mode"
    fi
### TODO html file query
    [ -z "$CEN_OPT_BASE" ] && config_fldr
    if [ -n "$CEN_OPT_FILE" ] ; then
        quit "Not implemented: --file"
    fi
    CEN_OPT_FILE="$DAT_BASENAME.js"     # always update_file ...
    temp='temperature_inside="-"; temperature_outside="-";'
    create -t -v temp -- "$CEN_OPT_FILE"
    # no '-p': centauri-bash-lib would run a subshell causing a hang
    system -e -- "$DAT_BASENAME.bash"
    if [ -n "$DAT_QMLVERSION" ] ; then
        system "$DAT_BASENAME.qml"
    else
        system x-www-browser "file:$DAT_BASENAME.html"
    fi

    message "Terminating..."
    CEN_VERB=0
    pkill -s0 "^$CEN_NAME|^mosquitto_sub"
}

run_data() {
    message "Starting data mode"
    local item updt='update_text'

    # check pre requisites
    system -c -f mosquitto_sub
    if [ -n "$CEN_OPT_FILE" ] ; then
        [ "$CEN_OPT_FILE" = '-' ] && CEN_OPT_FILE='/dev/stdout'
        [ -w "$CEN_OPT_FILE" ] ||
            quit $"Cannot write to file:" "$CEN_OPT_FILE" "user=$USER" "PWD=$PWD"
        updt='update_file'
    elif [ -n "$CEN_OPT_ASCII" ] ; then
        system -c -f toilet clear
        system -f -s DAT_OUTPUT_CLEAR -- clear
        updt='update_clock'
    fi

    # use MQtt topics from command line
    if [ $# != 0 ] ; then
        DAT_MQTOPICS=()
        for item in "$@" ; do
            DAT_MQTOPICS+=('-t' "$item")
        done
    fi

    # try to enable 'sleep' as builtin (see apt install bash-builtins)
    if ! enable sleep &>/dev/null ; then
        system -f -c -- sleep
        trace -a  -c 'bash builtin' $"No 'sleep' loadable, using external tool"
    fi

    # launch MQtt subscriber using a pipe for payload data
    tmpfile -r -n -s DAT_MQTTPIPE || quit
    system -e -p -- mkfifo "$DAT_MQTTPIPE" ; error -q
    subscriber >"$DAT_MQTTPIPE" & DAT_SUBSCRIBER=$!

    # start the serializer sub shell
    tmpfile -r -s DAT_UPDATED || quit
    tmpfile -r -s DAT_MQTTDATA || quit
    serializer & DAT_SERIALIZER=$! ; error -q

    # check if sub-shells are alive
    trace -a -p "PIDs  subscriber=%s  serializer=%s" "$DAT_SUBSCRIBER" "$DAT_SERIALIZER"
    sleep 3                      # give them time to initialize
    kill -0 "$DAT_SUBSCRIBER" &>/dev/null || quit -e $"Subscriber process died"
    kill -0 "$DAT_SERIALIZER" &>/dev/null || quit -e $"Serializer process died"
    if [ -n "$DAT_DISPLAY" ] ; then
        kill -0 "$DAT_DISPLAY"    &>/dev/null || quit -e $"QML display process died"
    fi
    error -q

    message -a "Running data loop (use ^C to stop)..."
    while : ; do
        ((DAT_COUNTER += 1))
        sleep 1 ; $updt                 # call update_text or update_clock
    done
}

# ------------------------------------------------------------------------------
# Main loop
# ------------------------------------------------------------------------------
run() {
    case "$BASH_SOURCE" in
    ./*)    DAT_MYSELF="$PWD${BASH_SOURCE:1}" ;;
    /*)     DAT_MYSELF="$BASH_SOURCE" ;;
    *)      system -s DAT_MYSELF -e -- realpath "$BASH_SOURCE" ;;
    esac

# TODO URL
    [ -n "$CEN_OPT_BASE" ] && config_fldr

    # -I implies -A    -A implies -C
    if [ -z "$CEN_OPT_INDENT" ] ; then
        CEN_OPT_INDENT='2,0'
    else
        [ -z "$CEN_OPT_ASCII" ] && CEN_OPT_ASCII=2
    fi
 #   [ -n "$CEN_OPT_ASCII" ]  && CEN_OPT_CLOCK=1

    case "$CEN_OPT_ASCII" in
    '') ;;
    off) CEN_OPT_ASCII=0 ;;
    on)  CEN_OPT_ASCII=1 ;;
    *)   [ "${TERM:-dumb}" = 'dumb' ] && CEN_OPT_ASCII=1 || CEN_OPT_ASCII=2 ;;
    esac

    for item in 1 2 3 15 ; do
        trap 'echo ; quit $"Terminating..."' "$item"
    done

    if [ -n "$CEN_OPT_CLOCK" ] ; then
        # CEN_OPT_FILE
        run_clock
    else
        run_data "$@"
    fi
}

# ------------------------------------------------------------------------------
# Custom options
# ------------------------------------------------------------------------------
options() {
    case "$1" in
    -A|--asc*)          optarg 'ascii'  -   -t ;;       # text
    -B|--bas|--base)    optarg 'base'   -   -t ;;       # text
    -C|--clo*)          optarg 'clock'  -   -f ;;       # flag
    -F|--fil|--file)    optarg 'file'   -   -t ;;       # text
    -H|--hos|--host)    optarg 'host'   -   -t ;;       # text
    -I|--ind*)          optarg 'indent' -   -t ;;       # text
    -T|--ter*)          optarg 'term'   -   -f ;;       # flag
    -U|--url)           optarg 'url'    -   -t ;;       # text
    -V|--vie*)          optarg 'viewer' -   -t ;;       # text
    -W|--wai|--wait)    optarg 'wait'   -   -t ;;       # text
    esac
}

# ------------------------------------------------------------------------------
# Help implementation
# ------------------------------------------------------------------------------
usage() {
    usagecat <<!EOF
Usage:     (1) $CEN_NAME [-d|-h] [-v|-q] [-H <host>] [-W <port>] <topic>...
           (2) $CEN_NAME [-d|-h] [-v|-q] -C [-A <mode>] [-H <host>] [-I <idnt>]
           ${CEN_NAME//?/°}     [-W <port>] <topic>...
           (3) $CEN_NAME [-d|-h] [-v|-q] -F [-H <host>]
           ${CEN_NAME//?/°}     [-W <port>] <topic>...

           Form (1) prints received data, form (2) displays a clock/thermometer
           and form (3) writes data to a file in Java-Script format. All mqtt
           date must be in JSON format with quoted topic names and values.

Options:   -d --dryrun          show what would be done, make no changes
           -h --help            show this text
           -q --quiet           report errors only
           -v --verbose         be verbose

           -A --ascii   <mode>  use pure ASCII (for console screen font)
           -B --base    <fldr>  use/create a configuration folder
           -C --clock           clock mockup, inside/outside temperature
           -F --file    <path>  dump data to file
           -H --host    <host>  MQtt host name (+ options if needed)
           -I --indent  <idnt>  indent clock by columns/rows
           -T --terminal        terminal mode (full screen)
           -U --url     <hurl>  HTML url used to load data from a web server
           -V --viewer  <view>  viewer/browser command line
           -W --wait    <port>  wait for connection to become ready

Arguments: <fldr>       folder path, use '-' for '$DAT_BASEDIR'
           <host>       mosquitto_sub arguments, see example
           <hurl>       html/htmls only, server must support CORS
           <idnt>       text mode indent, <cols>.<rows>, see example
           <mode>       prefer text mode (0|off mono, 1|on pure ASCII, 2|auto)
           <port>       mqtt broker port to wait for, use port 1883 when '-'
           <topic>      topics to subscribe to. Should contain a I'temperature'
           °            field in payload. All other fields ignored
           <view>       command line for alternate viewer (without URL). The
                        tool's main process must not go to background

Examples:  # use -H to pass <host> and options to mosquitto_sub (quoted!)
           $CEN_NAME -v -H 'raspi1.at.home -p 1883 -u otto'
           $CEN_NAME -H 'raspi1'

           # use -B to configurate the clock-mode temperature display
           $CEN_NAME -B - 'myhost'          # without web-server
           $CEN_NAME -B - -U 'http://...'   # to use a web-server

           # to write data to a file (maybe on a web server)
           $CEN_NAME -F mydata.js -H mymqtt

           # the default options/arguments are:
           $CEN_NAME -H 'localhost' weewx/inside weewx/outside

           # run in clock mode:
           $CEN_NAME -q -H 'raspi1' -C      # HTML version if possible
           $CEN_NAME -q -H 'raspi1' -A2 -C  # force ASCII mok-up
           $CEN_NAME -I 40.12               # -C and -A2 are implied

Packages:  ASCII mode needs:    "toilet" "toilet-fonts"
           HTML mode needs:     "qml" (bookworm) | "qml-qt6" (trixie or later)
           °                    "falkon" (not realy used but load dependencies)

Note:      It may take a while until MQtt data gets updated and shown

!EOF
}

### mini-bash-lib packed ###
if [ -z "$CEN_HOOK_MESSAGE" ];then
{
{
CEN_STDOUT=41
CEN_STDERR=42
eval exec "$CEN_STDOUT>&1" "$CEN_STDERR>&2"
CEN_EXIT=0
CEN_HOOK_MESSAGE='message'
CEN_HOOK_QUIT='_cen_quit'
CEN_IDNT=
CEN_MINI_VERSION='0.07'
: "${CEN_VERSION:=$CEN_MINI_VERSION}"
CEN_ARGS=
CEN_ARGOPT=
CEN_ACTARR=
CEN_CONFIRM=
CEN_OPT_DRYRUN=
CEN_OPT_FORCE=
CEN_TMP_BASE="${TMPDIR:-/tmp}/$EPOCHSECONDS-$BASHPID-"
CEN_TMP_INDX=0
CEN_TMP_SYSO=
CEN_TMPFILE=
CEN_VERB=1
CEN_YESNO=
}
warning(){ message -w "$@";}
error(){ message -e -l "$@";return "$CEN_EXIT";}
fatal(){ [ "$1" = '-t' ]&&set -- "${@:2}";message -f -l "$@";quit;}
trace(){ [ "$CEN_VERB" -lt 2 ]&&return 0;message "$@";}
message(){
local _idnt="$CEN_NAME:" _exit _mesg _olog="$CEN_VERB" _opre _oqui _omul _opri
while [ "${1::1}" = - ];do
case "$1" in
-)break;;
--)shift;break;;
-a)[ -n "$CEN_IDNT" ]&&_idnt="${_idnt//?/ }";;
-c)
local _asci _ugly
_asci="${2//[[:alpha:]]/.}"
printf -v _ugly $"%-16s:" "$_asci"
printf -v _opre '%s' "${_ugly/$_asci/$2}"
shift;;
-e)_opre=$"***ERROR***";_exit=2;;
-f)_opre=$"***FATAL ERROR***";_exit=3;;
-i)_idnt="${_idnt//?/ }";;
-l)_olog=1;;
-m)_omul=1;;
-p)_opri=1;;
-q)[ "$CEN_EXIT" = 0 ]&&return 0;_oqui=1;;
-t)[ "$CEN_EXIT" = 0 ];return;;
-w)_opre=$"***WARNING***";;
esac;shift
done
[ -n "$_exit" ]&&{ _olog=1;CEN_EXIT="$_exit";}
[ -n "$_oqui" ]&&quit -e "$@"
[ "$_olog" -lt 1 ]&&return 0
if [ -n "$_omul" ];then
_omul="$1";shift
set -- "$_omul${@/*/$'\n'${_idnt//?/ } &}"
fi
[ -z "$_opri" ]&&_mesg="$*"||printf -v _mesg "$@"
[ -n "$_opre" ]&&_mesg="$_opre $_mesg"
echo "$_idnt" "$_mesg" >&2
CEN_IDNT=1
}
confirm(){
local _ofmt _oupc _what=1 _repl _vnam='CEN_CONFIRM' _idnt="$CEN_NAME:" _info _defn _text
while [ "${1::1}" = - ];do
case "$1" in
--)shift;break;;
-a)[ -n "$CEN_IDNT" ]&&_idnt="${_idnt//?/ }";;
-d)shift;_defn="$1";;
-f)_ofmt=1;;
-i)_idnt="${_idnt//?/ }";;
-n)_what=1;;
-p)shift;_what=;_info="$1";;
-s)shift;_vnam="$1";;
-u)_oupc=1;;
-y)_what=0
esac;shift
done
[ -z "$_ofmt" ]&&_text="$*"||printf -v _text "$@"
if [ -z "$_what" ];then
[ "$_info" = - ]&&_info=': '
read -p -r "$_idnt $_text$_info" _repl;CEN_IDNT=1
[ -z "$_repl" ]&&_repl="$_defn"
[ -z "$_oupc" ]&&_repl="${_repl,,}"
[ -n "$_vnam" ]&&printf -v "$_vnam" '%s' "$_repl"
[ -n "$_repl" ];return
fi
local _locy _locn _loqy _loqn _loca=$"yes°no° [Y/n]? ° [y/N]? "
IFS='°' read -r _locy _locn _loqy _loqn <<<"$_loca"
if [ -z "$CEN_YESNO" ];then
if [ "$_what" = 0 ];then
_defn="$_locy";_info="$_loqy"
else
_defn="$_locn";_info="$_loqn"
fi
while :;do
read -rp "$_idnt $_text$_info" _repl;CEN_IDNT=1
_repl="${_repl,,}"
case "${_repl::1}" in
'')  _repl="$_defn";break;;
"${_locn::1}") _repl="$_locn";break;;
"${_locy::1}") _repl="$_locy";break
esac
message -l $"Please enter 'yes' or 'no'"
done
else
[ "$CEN_YESNO" = 'y' ]&&_repl="$_locy"||_repl="$_locn"
fi
[ -n "$_vnam" ]&&printf -v "$_vnam" '%s' "$_repl"
[ "$_repl" = "$_locy" ]
}
create(){
local _rdry _rtru _vnam _fout _darr
while [ "${1::1}" = - ];do
case "$1" in
--)shift;break;;
-c)_vnam='-';;
-r)_rdry='-r';;
-t)_rtru=1;;
-v)shift;_vnam="$1"
esac;shift
done
[ "${1:--}" = - ]&&_fout='/dev/stdout'||_fout="$1"
if [ -z "$_rtru" ]&&[ "${_fout::5}" != '/dev/' ]&&[ -e "$_fout" ];then
trace -c $"Existing file" "$_fout";return 0
fi
dryrun $_rdry $"Create file" "$@"&&return 1
_cen_create_file "$_fout"||return 1
[ -z "$_vnam" ]&&return 0
if [ "$_vnam" = - ];then
local _darr;readarray -t _darr
else
local -n _darr="$_vnam"
fi
printf '%s\n' "${_darr[@]}" >"$_fout"
}
_cen_create_file(){
true >"$1" 2>/dev/null&&return 0;error $"Failed to create file:" "$1"
}
dryrun(){
local _rdry="$CEN_OPT_DRYRUN"
while [ "${1::1}" = - ];do
case "$1" in
--)shift;break;;
-r)_rdry=;;
esac;shift
done
if [ -z "$_rdry" ];then
trace -a -c $"Execute" "$@";return 1
fi
message -a -c $"Skip" "$@";return 0
}
embed(){
local _stat _opts=()
while [ "${1::1}" = - ];do
case "$1" in
--)shift;break;;
-m)return 0;;
-a|-s)_opts+=("$1" "$2");shift;;
-*)_opts+=("$1")
esac;shift
done
_opts+=('--' "$1" '--embed' "$CEN_NAME");shift
[ -n "$CEN_OPT_DRYRUN" ]&&_opts+=('--dryrun')
system -r "${_opts[@]}" "$@";_stat="$?"
[ "$_stat" = 3 ]&&quit -s 3;return "$_stat"
}
folder(){
local _ochg _omak _oerr='error' _oopt='-e -p'
while [ "${1::1}" = - ];do
case "$1" in
--)shift;break;;
-c)_ochg='cd';;
-f)_oerr='fatal';_oopt='-f -p';;
-m)_omak=1;;
-p)_ochg='cd -P';;
-q)_oerr=':';_oopt='-q';;
esac;shift
done
if [ ! -d "$1" ];then
if [ -n "$_omak" ];then
system $_oopt -- mkdir -p "$1"||return 1
else
$_oerr $"Not a folder:" "$1";return 1
fi
fi
[ -z "$_ochg" ]&&return 0
system -r $_oopt -- eval "$_ochg" "$1"||return 1
trace -a -c $"Current folder" "$PWD";return 0
}
splitjoin(){
local _sopt _deli
while [ "${1::1}" = - ];do
case "$1" in
--)shift;break;;
-d)shift;printf -v _deli "$1";;
-s)shift;local -n _vjsx="$1";_sopt=1;;
-j)shift;local -n _vjsx="$1";_sopt=2;;
esac;shift
done
case "$_sopt" in
1)[ -z "$_deli" ]&&_deli=$'\t\n'
local _sifs="$IFS"
set -f;IFS="$_deli" _vjsx=($*);set +f;IFS="$_sifs";;
2)[ -z "$_deli" ]&&_deli=$'\t'
printf -v _vjsx "${_deli::1}%s" "$@";_vjsx="${_vjsx:1}";;
*)return 1
esac;return 0
}
copy(){ _cen_simple_cmd 'cp' "$@";}
rename(){ _cen_simple_cmd 'mv' "$@";}
remove(){ _cen_simple_cmd 'rm' -F "$@";}
symlink(){ _cen_simple_cmd 'ln' -S "$@";}
_cen_simple_cmd(){
local _oerr='-e -p' _orun _args=("$1");shift
while [ "${1::1}" = - ];do
case "$1${_args::1}" in
--?)shift;break;;
-ac)_args+=('-a');;
-uc)_args+=('-u');;
-dr)_args+=('-r');;
-Fr)_args+=('-f');;
-or)_args+=('--one-file-system');;
-nl)_args+=('-f');;
-rl)_args+=('-r');;
-Sl)_args+=('-s');;
-om)_args+=('-f');;
-f?)_oerr='-f -p';;
-q?)_oerr='-q';;
-r?)_orun=1;;
esac;shift
done
system $_oerr $_orun -- "${_args[@]}" "$@"
}
system(){
local _stat _rdry _fchk _olou _onam _ored _otyp _odel _oerr=':' _oqui=':'
while [ "${1::1}" = - ];do
case "$1" in
--)shift;break;;
-a)shift;_onam="$1";_ored=1;_otyp=2;;
-c)_fchk=1;;
-d)shift;_odel="$1";;
-e)_oerr='error';_olou='-l';;
-f)_oerr='message -f -l';_olou='-l';_oqui='quit';;
-p)_ored=1;[ -z "$_otyp" ]&&_otyp=0;;
-q)_ored=0;;
-r)_rdry='-r';;
-s)shift;_onam="$1";_ored=1;_otyp=1;;
-t)[ "$CEN_EXIT" = 0 ]||return 1;;
-w)_oerr='warning';;
-z)_ored=2;[ -z "$_otyp" ]&&_otyp=0;;
esac;shift
done
if [ -n "$_fchk" ];then
_stat=0
for _fchk in "$@";do
type -t "$_fchk" &>/dev/null&&continue
$_oerr -p $"Command '%s' not found" "$_fchk";_stat=127;$_oqui
done
return "$_stat"
fi
dryrun $_rdry "$@"&&return 1
[ -n "$_otyp" -a -z "$CEN_TMP_SYSO" ]&&tmpfile -r -s CEN_TMP_SYSO
case "$_ored" in
0)"$@" &>/dev/null;return;;
1)"$@" &>"$CEN_TMP_SYSO";_stat=$?;;
2)"$@" 2>"$CEN_TMP_SYSO";_stat=$?;;
*)"$@";_stat=$?
esac
[ "$_stat" = 0 -a -z "$_onam" ]&&return 0
if [ -n "$_otyp" ];then
[ "$_otyp" = 2 ]&&local -n _vsys="$_onam"||local _vsys
if [ "$_odel" = '--' ];then
readarray -t _vsys <"$CEN_TMP_SYSO"
else
local _sifs="$IFS" _list;readarray -t _list <"$CEN_TMP_SYSO";set +f
IFS=$'\n' _vsys=(${_list[*]});IFS="$_sifs";set -f
fi
[ "$_otyp" = 1 ]&&splitjoin -j "$_onam" -- "${_vsys[@]}"
fi
[ "$_stat" = 0 ]&&return 0
CEN_IDNT=;$_oerr -p $"Running '%s' failed (status %s)" "$1" "$_stat"
[ -n "$_otyp" ]&&message -a -m $_olou -- "${_vsys[@]}"
$_oqui;return "$_stat"
}
tmpfile(){
local _vtmp='CEN_TEMPFILE' _rdry _crea=1
local _temp="$CEN_TMP_BASE$CEN_TMP_INDX-$BASHPID"
((CEN_TMP_INDX += 1))
while [ "${1::1}" = - ];do
case "$1" in
-n)_crea=;;
-r)_rdry='-r';;
-s)shift;_vtmp="$1";;
esac;shift
done
printf -v "$_vtmp" '%s' "$_temp"
[ -z "$_crea" ]&&return 0
dryrun $_rdry $"Temporary file" "$_temp"&&return 1
_cen_create_file "$_temp"
}
main(){
if [ "${CEN_NAME:--}" = - ] ;then
CEN_NAME="${BASH_ARGV0##*/}"
CEN_FEATURE_F=1;CEN_FEATURE_Y=1
fi
local _opts=':';PATH=' ' type -t 'options' &>/dev/null&&_opts='options'
while [ "${1::1}" = - ];do
CEN_ARGS=;CEN_ARGOPT=;CEN_ACTION="$1";CEN_ACTARR="$2"
case "$1" in
--*=*)CEN_ARGOPT="${1#*=}";CEN_ACTION="${1%%=*}";;
-[^-]*)CEN_ARGOPT="${1:2}";CEN_ACTION="${1::2}";;
--|---)shift;break;;
esac
$_opts "$CEN_ACTION" "${CEN_ARGOPT:-$2}"
[ -z "$CEN_ARGS" ]&&CEN_ARGS=1&&case "$CEN_ACTION" in
-d|--dry*)CEN_OPT_DRYRUN=1;;
-f|--for*)[ -n "$CEN_FEATURE_F" ]&&CEN_OPT_FORCE=1||CEN_ARGS=0;;
-h|--help)PATH=' ' type -t usage &>/dev/null&&{ usage >&2;quit -s 2;}
quit $"Option '--help' is not implemented";;
-n|--no)[ -n "$CEN_FEATURE_Y" ]&&CEN_YESNO='n'||CEN_ARGS=0;;
-q|--qui*)CEN_VERB=0;;
-v|--ver*)CEN_VERB=2;;
-y|--yes)[ -n "$CEN_FEATURE_Y" ]&&CEN_YESNO='y'||CEN_ARGS=0;;
--embed)optarg - CEN_NAME -t;;
--info)quit -p "mini-bash-lib $CEN_MINI_VERSION; '%s'; %s" "$CEN_VERSION" \
"${CEN_LEGAL:-$"<unknown Author/Licence>"}";;
--mini*);;
--trace)set -x;;
*) CEN_ARGS=
esac
[ "${CEN_ARGS:-0}" -lt 1 ]&&quit -e $"Unknown option:" "$1"
[ "$CEN_ARGS" -gt $# ]&&CEN_ARGS="$#";shift "$CEN_ARGS"
done
CEN_ACTARR=;CEN_ARGOPT=;CEN_ACTION=;$_opts
PATH=' ' type -t run &>/dev/null||return 2;run "$@"
}
optarg(){
local _name="${2:--}" _aarr="$CEN_ACTARR"
[ "$_name" = - ]&&_name="CEN_OPT_${1^^}"
case "${3:--f}" in
-f)printf -v "$_name" '%s' "${4:-1}";CEN_ARGS=1;;
*)if [ -z "$CEN_ARGOPT" ];then
[ "$_aarr" != - ]&&[ -z "$_aarr" -o "${_aarr::1}" = '-' ] &&
quit -e $"Missing option value:" "--$1"
CEN_ARGS=2;CEN_ARGOPT="$_aarr"
else
CEN_ARGS=1
fi
[ "$CEN_ARGOPT" = - ]&&CEN_ARGOPT="${4:--}";printf -v "$_name" '%s' "$CEN_ARGOPT"
esac
}
quit(){
"$CEN_HOOK_QUIT" "$@"
}
_cen_quit(){
local _opts=() _term
while [ "${1::1}" = - ];do
case "$1" in
-)break;;
--)shift;break;;
-e)_term=$"Terminated after error";CEN_EXIT=1;_opts+=('-e');;
-h)return;;
-s)shift;CEN_EXIT="$1";;
-t|-u)_term=$"Terminated";CEN_EXIT=4;;
*)_opts+=("$1");;
esac;shift
done
if [ -n "$_term" ];then
if [ $# = 0 ];then set -- "$_term"
elif [ "$*" = - ];then set --
elif [ "$1" = - ];then set -- "$_term""${2:+:}" "${@:2}"
fi
fi
[ -n "$*" ]&&message "${_opts[@]}" "$@"
[ "$CEN_TMP_INDX" != 0 -a -n "$CEN_TMP_BASE" ]&&system -q -r -- rm -f "$CEN_TMP_BASE"*
trace -a -c $"Script exits" "STATUS=$CEN_EXIT";exit "$CEN_EXIT"
}
usagecat(){
local _larr _labl _line;readarray -t -u 0 _larr
for _line in "${_larr[@]}";do
[ "$1" = '-l' ]&&{ printf '%s\n' "$_line";continue;}
case "$_line" in
[a-zA-z]*:*) _labl="${_line%%:*}:";_line="${_line#*:}";;
*)_labl=;;
esac
_line="${_line#"${_line%%[![:space:]]*}"}"
printf '%-11s%s\n' "$_labl" "${_line//°/ }"
done
}
command_not_found_handle(){
set +xeE;exec 1>&"$CEN_STDOUT" 2>&"$CEN_STDERR"
message -l $"***ABORT***" $"Command not found:" "$1"
kill -42 $$
}
trap 'trap 42; quit -s 127' 42
}
if PATH=' ' type -t run &>/dev/null;then
main "$@";quit
fi
elif [ -n "$CEN_STAGE" ];then
run "$@"
else
main "$@";quit
fi
### mini-bash-lib end ###
